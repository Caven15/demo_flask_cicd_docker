# ============================================================
# CI - étapes 1 : Tests automatiques uniquement (CI simple)
# ============================================================

name: CI - étapes 1 (test uniquement)

#region Déclencheurs du workflows
on:
  # Exécuter la CI à chaque PR vers le main
  pull_request:
    branches: [main]

  # Exécuter la CI à chaque push directe sur le main
  push:
    branches: [main]

  # Lancement manuel depuis l'interface GitHub Actions
  workflow_dispatch:
#endregion

#region Permissions minimales
permissions: 
  contents: write
  pull-requests: write

#endregion

#region Définition des jobs
jobs:

  #region JOB 1 - CI : Intégration continue
  ci_pipeline:
    runs-on: ubuntu-latest  # Runner Ubuntu GitHub

    steps:
      #region Étape 1 - Récupération du code source
      - name: Checkout du code
        uses: actions/checkout@v4
        # Récupère l'état du dépôt au SHA de la PR/push
      #endregion

      #region Étape 2 - Installation de Python
      - name: Configurer Python
        uses: actions/setup-python@v5
        with:
          python-version: 3.11  # Adapter la version à celle utilisée par ton projet
      #endregion

      #region Étape 3 - Installation des dépendances
      - name: Installer les dépendances
        working-directory: back-end
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt  # ⚠️ Le fichier doit inclure pytest
      #endregion

      #region Étape 4 - Exécution des tests unitaires
      - name: Lancer les tests unitaires
        working-directory: back-end
        run: |
          export PYTHONPATH=.
          pytest -v
      #endregion

      #region Étape 5 - Auto-merge de la pull request
      - name: Auto merge de la pull request
        # notre étape ne s'executera que si :
        # - tout les test précédent qui on reussi (success())
        # - l'événement est une 'pull_request' (et non un push direct)
        if: ${{success() && github.event_name == 'pull_request'}}
        uses: pascalgn/automerge-action@v0.16.4
        env:
          GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}} # authentification GitHub
          MERGE_METHOD: squash                    # Fusion en squash (compacter tout les commit)
          MERGE_DELETE_BRANCH: true               # supprimer la branche une fusionnée
          MERGE_LABELS: ""                        # LAbel requis pour un merge
          MERGE_RETRIES: 6                        # réessaie jusqu'a 6 si la PR n'est pas encore prête
          MERGE_RETRIES_SLEEP: 10000              # délai (ms) entre chaque tentative
          # notre action vient de la marketplace GitHub (pascalgn/automerge-action)
          # Elle automatise le merge de PR validées 
      #endregion
  
  #endregion

  #region JOB 2 - CD : Tag + Release
  create_release:
    needs: ci_pipeline # Attendre la fin du job CI (test + automerge & delete de la branche subsidiaire)
    runs-on: ubuntu-latest
    # Condition
    # - a PR vient d'ête fusionnée (cas principal)
    # - Ou su un push direct a été effectué sur le main  (hotfix)
    if: github.event.pull_request.merged == true || github.ref == 'refs/heads/main'

    steps:
      #region 1 : checkout propre pour le job CD
      - name: Checkout du code
        uses: actions/checkout@v4
      #endregion

      #region 2 : Création automatique d'un tag
      - name: Créer un tag automatique
        id : tag
        uses : anothrNick/github-tag-action@1.75.0
        env:
          GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}
          DEFAULT_BUMP: patch
          RELEASE_BRANCHES: main
          # L'objectif de notre action est de calculé la prochaine version
          # et créer un tag (1.0.2 => 1.0.3) => Bump par default PATCH
      #endregion

      #region 3 : Création de la Realase GitHub
      - name: Créer un une release GitHub à partir du tag
        uses: softprops/action-gh-release@v2.4.1
        with:
          tag_name: ${{steps.tag.outputs.new_tag}}
          name: "Version ${{steps.tag.outputs.new_tag}}"
          body: |
            Nouvelle version publié automatiquement.

            Détails du pipeline:
              - Test unitaires validés
              - Pull Request fusionné dans 'Main'
              - Branche Feature supprimé (Trunk base)
              - Tag & Release créés
        env:
          GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}
      #endregion
  #endregion

  #region JOB 3 - CD Local : Déploiement Docker en local
  deploy_local_docker:
    # On attend que :
    # - les tests soient OK
    # - la release/tag soit créé
    needs: create_release

    # ce job tourne sur le runner self-hosted
    runs-on: self-hosted

    # On ne déploie que lorsqu'on est sur la branche main
    if: github.ref == 'refs/heads/main'

    steps:
      #region 1 : Checkout du code sur la machine locale
      - name: Checkout du code
        uses: actions/checkout@v4
        # Le runner récupère le code à jour de la branche main
      #endregion

      #region 2 : Arrêter l'ancienne version (si elle tourne)
      - name: Arrêter l'ancienne stack Docker (si existante)
        run: |
          echo "Arrêt de l'ancienne version (si existante)..."
          docker compose down
        continue-on-error: true

      #endregion

      #region 3 : Build & démarrage de la nouvelle version
      - name: Build & démarrer la nouvelle version
        run: |
          echo "Build + démarrage de la nouvelle version..."
          docker compose up -d --build
      #endregion

      #region 4 : Vérification basique de l'API en local
      - name: Vérification de l'API (health-check basique)
        shell: powershell
        run: |
          echo "Vérification de l'API sur http://localhost:5000/api/books..."
          try {
            $response = Invoke-WebRequest -Uri "http://localhost:5000/api/books" -UseBasicParsing -TimeoutSec 10
            if ($response.StatusCode -eq 200) {
              Write-Host "API OK - Statut 200"
            } else {
              Write-Error "API joignable mais statut inattendu : $($response.StatusCode)"
            }
          }
          catch {
            Write-Error "L'API ne répond pas ou renvoie une erreur : $($_.Exception.Message)"
          }

      #endregion
  #endregion

#endregion
